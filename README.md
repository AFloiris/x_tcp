#  `X_TCP` 模拟 TCP 协议

本实验是利用原始数据包的收发,模拟实现 TCP 协议

## 使用

直接执行 `make` 即可生成 `client` 与 `server` 两个可执行文件

## 实现的功能

1. TCP 三次握手
2. TCP 四次挥手
3. TCP 可靠数据传输
4. TCP 移动窗口
5. TCP 流量控制和拥塞控制
6. TCP 超时重传

## 代码主要执行流程

### 1. x_socket

创建一个原始套字节,接收所有 TCP 协议的数据包,且数据包包含 < IP头 TCP头 数据 >

### 2. x_bind

通过 BPF 过滤器,过滤到只接收数据包中目标地址为绑定地址的数据包

### 3. x_listen

创建一个数据读取线程,持续读取原始套字节的数据包,并进行数据包分析 `packet_handle()`

### 4. x_accept

当有连接成功三次握手时,会进入已连接队列,该函数会阻塞等待已连接队列直到有数据,返回连接并且启动对应的发送线程 `send_thread()` 与重传线程 `retran_thread()`

### 5. x_connect 

通过 BPF 过滤器,过滤到只接收数据包中目标地址为绑定地址的数据包,
创建一个数据读取线程,持续读取原始套字节的数据包,并进行数据包分析 `packet_handle()`,并且发送第一次握手的数据包,阻塞等待已连接队列直到有数据,启动对应的发送线程 `send_thread()` 与重传线程 `retran_thread()`

### 6. x_write

将数据写入 x_sock 的数据发送缓冲区,然后通过发送线程 `send_thread()` 将数据发送出去

### 7. x_read

阻塞读取 x_sock 数据读取缓冲区,当数据缓冲区有数据时,就返回数据给用户

### packet_handle

**数据包分析函数,主要函数之一**

通过 x_sock 当前状态与数据包中的 flags 判断当前处于什么阶段,并执行相对于的操作

例如: 处于监听状态的 x_sock 接收到 flags 为 SEQ 的数据包,则判断是收到了第一次握手的数据包,需要执行的操作为发送 SEQ+ACK 数据包

具体操作查看源码注释

 ### send_thread

 **数据包发送函数,主要函数之一**

当 x_sock 的数据发送缓冲区有数据并且不处于重传状态时,根据窗口大小发送数据,并且设置对应的序列号

具体操作查看源码注释

### retran_thread

**数据包重传函数,主要函数之一**

当收到重复的 ACK 包时,进入重传线程,并根据RTT重设窗口大小,重新发送未发送出去的数据

###  TimeoutInterval

**RTT时间估算**

通过发送数据包的时间与接收到对应ACK数据包的时间差计算RTT

### 其他函数查看源码注释